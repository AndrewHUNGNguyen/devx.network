<!doctype html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>DEVx Shader Viewer</title>
		<style>
			body {
				margin: 0;
				padding: 0;
				overflow: hidden;
				background: #000;
				font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
			}
			canvas {
				display: block;
				width: 100vw;
				height: 100vh;
			}
			.controls {
				position: absolute;
				top: 20px;
				left: 20px;
				z-index: 10;
				background: rgba(0, 0, 0, 0.8);
				padding: 20px;
				border-radius: 8px;
				color: white;
			}
			button {
				background: #4caf50;
				color: white;
				border: none;
				padding: 10px 20px;
				margin: 5px;
				border-radius: 4px;
				cursor: pointer;
				font-size: 14px;
			}
			button:hover {
				background: #45a049;
			}
			button:disabled {
				background: #666;
				cursor: not-allowed;
			}
			.recording {
				background: #f44336;
			}
			.recording:hover {
				background: #da190b;
			}
			.status {
				margin-top: 10px;
				font-size: 12px;
				color: #ccc;
			}
		</style>
	</head>
	<body>
		<div class="controls">
			<h3>Shader Controls</h3>
			<button id="recordBtn">Start Recording</button>
			<button id="screenshotBtn">Take Screenshot</button>
			<div class="status" id="status"></div>
		</div>
		<canvas id="canvas"></canvas>

		<script>
			// Noise utility functions
			const noiseUtils = `
		vec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
		vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
		vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
		vec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }
		vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
		vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
		vec3 fade(vec3 t) { return t*t*t*(t*(t*6.0-15.0)+10.0); }
		`

			// Simplex noise function
			const simplex_noise = `
		float simplex_noise(vec2 v) {
			const vec4 C = vec4(0.211324865405187, 0.366025403784439, -0.577350269189626, 0.024390243902439);
			vec2 i  = floor(v + dot(v, C.yy) );
			vec2 x0 = v -   i + dot(i, C.xx);
			vec2 i1;
			i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
			vec4 x12 = x0.xyxy + C.xxzz;
			x12.xy -= i1;
			i = mod289(i);
			vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 )) + i.x + vec3(0.0, i1.x, 1.0 ));
			vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);
			m = m*m ;
			m = m*m ;
			vec3 x = 2.0 * fract(p * C.www) - 1.0;
			vec3 h = abs(x) - 0.5;
			vec3 ox = floor(x + 0.5);
			vec3 a0 = x - ox;
			m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );
			vec3 g;
			g.x  = a0.x  * x0.x  + h.x  * x0.y;
			g.yz = a0.yz * x12.xz + h.yz * x12.yw;
			return 130.0 * dot(m, g);
		}

		float simplex_noise(vec3 v) {
			const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
			const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);
			vec3 i  = floor(v + dot(v, C.yyy) );
			vec3 x0 =   v - i + dot(i, C.xxx) ;
			vec3 g = step(x0.yzx, x0.xyz);
			vec3 l = 1.0 - g;
			vec3 i1 = min( g.xyz, l.zxy );
			vec3 i2 = max( g.xyz, l.zxy );
			vec3 x1 = x0 - i1 + C.xxx;
			vec3 x2 = x0 - i2 + C.yyy;
			vec3 x3 = x0 - D.yyy;
			i = mod289(i);
			vec4 p = permute( permute( permute(
				i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
				+ i.y + vec4(0.0, i1.y, i2.y, 1.0 ))
				+ i.x + vec4(0.0, i1.x, i2.x, 1.0 ));
			float n_ = 0.142857142857;
			vec3  ns = n_ * D.wyz - D.xzx;
			vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
			vec4 x_ = floor(j * ns.z);
			vec4 y_ = floor(j - 7.0 * x_ );
			vec4 x = x_ *ns.x + ns.yyyy;
			vec4 y = y_ *ns.x + ns.yyyy;
			vec4 h = 1.0 - abs(x) - abs(y);
			vec4 b0 = vec4( x.xy, y.xy );
			vec4 b1 = vec4( x.zw, y.zw );
			vec4 s0 = floor(b0)*2.0 + 1.0;
			vec4 s1 = floor(b1)*2.0 + 1.0;
			vec4 sh = -step(h, vec4(0.0));
			vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
			vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;
			vec3 p0 = vec3(a0.xy,h.x);
			vec3 p1 = vec3(a0.zw,h.y);
			vec3 p2 = vec3(a1.xy,h.z);
			vec3 p3 = vec3(a1.zw,h.w);
			vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
			p0 *= norm.x;
			p1 *= norm.y;
			p2 *= norm.z;
			p3 *= norm.w;
			vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
			m = m * m;
			return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) );
		}
		`

			// Vertex shader
			const vertexShaderSource = `
			attribute vec2 a_position;
			void main() {
				gl_Position = vec4(a_position, 0.0, 1.0);
			}
		`

			// Fragment shader with embedded functions
			const fragmentShaderSource = `
			precision mediump float;

			uniform float u_time;
			uniform float u_h;
			uniform float u_w;
			uniform sampler2D u_gradient;
			uniform float u_pixelRatio;
			
			const float PI = 3.14159;

			float WAVE1_Y, WAVE2_Y;
			float WAVE1_HEIGHT, WAVE2_HEIGHT;
			
			${noiseUtils}
			${simplex_noise}

			float get_x() {
				float scaledX = gl_FragCoord.x / u_pixelRatio;
				return 900.0 + scaledX - u_w / 2.0;
			}
			
			float smoothstep(float t) {
				return t * t * t * (t * (6.0 * t - 15.0) + 10.0);
			}

			float lerp(float a, float b, float t) {
				return a * (1.0 - t) + b * t;
			}

			float ease_in(float x) {
				return 1.0 - cos((x * PI) * 0.5);
			}

			float pow_approx(float x) {
				return x*(0.6 + 0.4*x);
			}

			float wave_alpha_part(float dist, float blur_fac, float t) {
				float exp = mix(0.90000, 1.20000, t);
				float v = pow_approx(blur_fac);
				v = ease_in(v);
				v = smoothstep(v);
				v = clamp(v, 0.008, 1.0);
				v *= 1000.0;  // Updated to match PotionBackground blurAmount
				float alpha = clamp(0.5 + dist / v, 0.0, 1.0);
				alpha = smoothstep(alpha);
				return alpha;
			}

			float background_noise(float offset) {
				const float S = 0.064;
				const float L = 0.00085;
				const float L1 = 1.5, L2 = 0.9, L3 = 0.6;
				const float LY1 = 1.00, LY2 = 0.85, LY3 = 0.70;
				const float F = 0.04;
				const float Y_SCALE = 1.0 / 0.27;

				float x = get_x() * L;
				float y = (gl_FragCoord.y / u_pixelRatio) * L * Y_SCALE;
				float time = u_time + offset;
				float x_shift = time * F;
				float sum = 0.5;
				sum += simplex_noise(vec3(x * L1 +  x_shift * 1.1, y * L1 * LY1, time * S)) * 0.30;
				sum += simplex_noise(vec3(x * L2 + -x_shift * 0.6, y * L2 * LY2, time * S)) * 0.25;
				return sum;
			}

			float wave_y_noise(float offset) {
				const float L = 0.000845;
				const float S = 0.075;
				const float F = 0.026;

				float time = u_time + offset;
				float x = get_x() * 0.000845;
				float y = time * S;
				float x_shift = time * 0.026;

				float sum = 0.0;
				sum += simplex_noise(vec2(x * 1.30 + x_shift, y * 0.54)) * 0.85;
				sum += simplex_noise(vec2(x * 1.00 + x_shift, y * 0.68)) * 1.15;
				sum += simplex_noise(vec2(x * 0.70 + x_shift, y * 0.59)) * 0.60;
				return sum;
			}

			float calc_blur_bias() {
				const float S = 0.261;
				float bias_t = (sin(u_time * S) + 1.0) * 0.5;
				return lerp(-0.17, -0.04, bias_t);
			}

			float calc_blur(float offset) {
				const float L = 0.0011;
				const float S = 0.07;
				const float F = 0.03;
				
				float time = u_time + offset;

				float x = get_x() * L;
				float blur_fac = calc_blur_bias();
				blur_fac += simplex_noise(vec2(x * 0.60 + time * F *  1.0, time * S * 0.7)) * 0.5;
				blur_fac += simplex_noise(vec2(x * 1.30 + time * F * -0.8, time * S * 1.0)) * 0.4;
				blur_fac = (blur_fac + 1.0) * 0.5;
				blur_fac = clamp(blur_fac, 0.0, 1.0);
				return blur_fac;
			}

			float wave_alpha(float Y, float wave_height, float offset) {
				float wave_y = Y + wave_y_noise(offset) * wave_height;
				float dist = wave_y - (gl_FragCoord.y / u_pixelRatio);
				float blur_fac = calc_blur(offset);
				
				const float PART = 1.0 / 3.0;
				float sum = 0.0;
				for (int i = 0; i < 3; i++) {
					float t = 3 == 1 ? 0.5 : PART * float(i);
					sum += wave_alpha_part(dist, blur_fac, t) * PART;
				}
				return sum;
			}
			
			vec3 calc_color(float lightness) {
				lightness = clamp(lightness, 0.0, 1.0);
				return vec3(texture2D(u_gradient, vec2(lightness, 0.5)));
			}
			
			void main() {
				// Initialize wave variables
				WAVE1_Y = 0.45 * u_h;
				WAVE2_Y = 0.9 * u_h;
				WAVE1_HEIGHT = 0.195 * u_h;
				WAVE2_HEIGHT = 0.144 * u_h;
				
				float bg_lightness = background_noise(-192.4);
				float w1_lightness = background_noise( 273.3);
				float w2_lightness = background_noise( 623.1);

				float w1_alpha = wave_alpha(WAVE1_Y, WAVE1_HEIGHT, 112.5 * 48.75);
				float w2_alpha = wave_alpha(WAVE2_Y, WAVE2_HEIGHT, 225.0 * 36.00);

				float lightness = bg_lightness;
				lightness = lerp(lightness, w2_lightness, w2_alpha);
				lightness = lerp(lightness, w1_lightness, w1_alpha);

				gl_FragColor = vec4(calc_color(lightness), 1.0);
			}
		`

			// Initialize WebGL
			const canvas = document.getElementById("canvas")
			const gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl")

			if (!gl) {
				alert("WebGL not supported")
				throw new Error("WebGL not supported")
			}

			// Compile shaders
			function compileShader(gl, source, type) {
				const shader = gl.createShader(type)
				gl.shaderSource(shader, source)
				gl.compileShader(shader)

				if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
					console.error("Shader compilation error:", gl.getShaderInfoLog(shader))
					gl.deleteShader(shader)
					return null
				}

				return shader
			}

			// Create shader program
			const vertexShader = compileShader(gl, vertexShaderSource, gl.VERTEX_SHADER)
			const fragmentShader = compileShader(gl, fragmentShaderSource, gl.FRAGMENT_SHADER)

			const program = gl.createProgram()
			gl.attachShader(program, vertexShader)
			gl.attachShader(program, fragmentShader)
			gl.linkProgram(program)

			if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
				console.error("Program linking error:", gl.getProgramInfoLog(program))
				throw new Error("Program linking failed")
			}

			gl.useProgram(program)

			// Set up geometry (full screen quad)
			const vertices = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1])

			const buffer = gl.createBuffer()
			gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
			gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW)

			const positionLocation = gl.getAttribLocation(program, "a_position")
			gl.enableVertexAttribArray(positionLocation)
			gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0)

			// Get uniform locations
			const uniforms = {
				u_time: gl.getUniformLocation(program, "u_time"),
				u_h: gl.getUniformLocation(program, "u_h"),
				u_w: gl.getUniformLocation(program, "u_w"),
				u_gradient: gl.getUniformLocation(program, "u_gradient"),
				u_pixelRatio: gl.getUniformLocation(program, "u_pixelRatio")
			}

			// Create gradient texture
			const gradientCanvas = document.createElement("canvas")
			gradientCanvas.width = 512
			gradientCanvas.height = 1
			const ctx = gradientCanvas.getContext("2d")

			// Create gradient matching DEVx theme from PotionBackground.tsx
			const gradient = ctx.createLinearGradient(0, 0, 512, 0)
			gradient.addColorStop(0.0, "#000001")
			gradient.addColorStop(0.25, "#08080a")
			gradient.addColorStop(0.45, "#15151c")
			gradient.addColorStop(0.65, "#0f0f16")
			gradient.addColorStop(0.85, "#000001")
			gradient.addColorStop(1.0, "#1c1c28")

			ctx.fillStyle = gradient
			ctx.fillRect(0, 0, 512, 1)

			// Create WebGL texture from gradient
			const gradientTexture = gl.createTexture()
			gl.bindTexture(gl.TEXTURE_2D, gradientTexture)
			gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, gradientCanvas)
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR)
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR)
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE)
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE)

			// Resize handler
			function resize() {
				canvas.width = window.innerWidth * window.devicePixelRatio
				canvas.height = window.innerHeight * window.devicePixelRatio
				canvas.style.width = window.innerWidth + "px"
				canvas.style.height = window.innerHeight + "px"
				gl.viewport(0, 0, canvas.width, canvas.height)
			}

			window.addEventListener("resize", resize)
			resize()

			// Animation loop
			let startTime = Date.now()
			function render() {
				const currentTime = (Date.now() - startTime) / 1000

				gl.uniform1f(uniforms.u_time, currentTime)
				gl.uniform1f(uniforms.u_h, canvas.height / window.devicePixelRatio / 3) // Divide by 3 like PotionBackground
				gl.uniform1f(uniforms.u_w, canvas.width / window.devicePixelRatio)
				gl.uniform1f(uniforms.u_pixelRatio, window.devicePixelRatio * 2) // Multiply by 2 like PotionBackground
				gl.uniform1i(uniforms.u_gradient, 0)

				gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4)

				requestAnimationFrame(render)
			}

			render()

			// Recording functionality
			let mediaRecorder
			let recordedChunks = []
			let isRecording = false

			const recordBtn = document.getElementById("recordBtn")
			const screenshotBtn = document.getElementById("screenshotBtn")
			const statusDiv = document.getElementById("status")

			// Setup recording
			recordBtn.addEventListener("click", () => {
				if (!isRecording) {
					startRecording()
				} else {
					stopRecording()
				}
			})

			function startRecording() {
				recordedChunks = []

				const stream = canvas.captureStream(30) // 30 FPS
				const options = {
					mimeType: "video/webm;codecs=vp9",
					videoBitsPerSecond: 8000000 // 8 Mbps
				}

				// Fallback options
				if (!MediaRecorder.isTypeSupported(options.mimeType)) {
					options.mimeType = "video/webm;codecs=vp8"
					if (!MediaRecorder.isTypeSupported(options.mimeType)) {
						options.mimeType = "video/webm"
					}
				}

				try {
					mediaRecorder = new MediaRecorder(stream, options)

					mediaRecorder.ondataavailable = (event) => {
						if (event.data.size > 0) {
							recordedChunks.push(event.data)
						}
					}

					mediaRecorder.onstop = () => {
						const blob = new Blob(recordedChunks, { type: "video/webm" })
						const url = URL.createObjectURL(blob)
						const a = document.createElement("a")
						a.href = url
						a.download = `shader_recording_${new Date().getTime()}.webm`
						a.click()
						URL.revokeObjectURL(url)
						statusDiv.textContent = "Recording saved!"
						setTimeout(() => (statusDiv.textContent = ""), 3000)
					}

					mediaRecorder.start()
					isRecording = true
					recordBtn.textContent = "Stop Recording"
					recordBtn.classList.add("recording")
					statusDiv.textContent = "Recording..."
				} catch (error) {
					console.error("Error starting recording:", error)
					statusDiv.textContent = "Error: " + error.message
				}
			}

			function stopRecording() {
				if (mediaRecorder && isRecording) {
					mediaRecorder.stop()
					isRecording = false
					recordBtn.textContent = "Start Recording"
					recordBtn.classList.remove("recording")
					statusDiv.textContent = "Processing..."
				}
			}

			// Screenshot functionality
			screenshotBtn.addEventListener("click", () => {
				canvas.toBlob((blob) => {
					const url = URL.createObjectURL(blob)
					const a = document.createElement("a")
					a.href = url
					a.download = `shader_screenshot_${new Date().getTime()}.png`
					a.click()
					URL.revokeObjectURL(url)
					statusDiv.textContent = "Screenshot saved!"
					setTimeout(() => (statusDiv.textContent = ""), 3000)
				}, "image/png")
			})
		</script>
	</body>
</html>
